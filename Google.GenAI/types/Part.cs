/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Auto-generated code. Do not edit.

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Google.GenAI.Serialization;

namespace Google.GenAI.Types {
  /// <summary>
  /// A datatype containing media content.  Exactly one field within a Part should be set,
  /// representing the specific type of content being conveyed. Using multiple fields within the
  /// same `Part` instance is considered invalid.
  /// </summary>

  public record Part {
    /// <summary>
    /// A predicted [FunctionCall] returned from the model that contains a string representing the
    /// [FunctionDeclaration.name] and a structured JSON object containing the parameters and their
    /// values.
    /// </summary>
    [JsonPropertyName("functionCall")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public FunctionCall ? FunctionCall { get; set; }

    /// <summary>
    /// Optional. Result of executing the [ExecutableCode].
    /// </summary>
    [JsonPropertyName("codeExecutionResult")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public CodeExecutionResult
        ? CodeExecutionResult {
            get; set;
          }

    /// <summary>
    /// Optional. Code generated by the model that is meant to be executed.
    /// </summary>
    [JsonPropertyName("executableCode")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public ExecutableCode
        ? ExecutableCode {
            get; set;
          }

    /// <summary>
    /// Optional. URI based data.
    /// </summary>
    [JsonPropertyName("fileData")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public FileData
        ? FileData {
            get; set;
          }

    /// <summary>
    /// Optional. The result output of a [FunctionCall] that contains a string representing the
    /// [FunctionDeclaration.name] and a structured JSON object containing any output from the
    /// function call. It is used as context to the model.
    /// </summary>
    [JsonPropertyName("functionResponse")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public FunctionResponse
        ? FunctionResponse {
            get; set;
          }

    /// <summary>
    /// Optional. Inlined bytes data.
    /// </summary>
    [JsonPropertyName("inlineData")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Blob
        ? InlineData {
            get; set;
          }

    /// <summary>
    /// Optional. Text part (can be code).
    /// </summary>
    [JsonPropertyName("text")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string
        ? Text {
            get; set;
          }

    /// <summary>
    /// Optional. Indicates if the part is thought from the model.
    /// </summary>
    [JsonPropertyName("thought")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool
        ? Thought {
            get; set;
          }

    /// <summary>
    /// Optional. An opaque signature for the thought so it can be reused in subsequent requests.
    /// </summary>
    [JsonPropertyName("thoughtSignature")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public byte[]
        ? ThoughtSignature {
            get; set;
          }

    /// <summary>
    /// Optional. Video metadata. The metadata should only be specified while the video data is
    /// presented in inline_data or file_data.
    /// </summary>
    [JsonPropertyName("videoMetadata")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public VideoMetadata
        ? VideoMetadata {
            get; set;
          }

    /// <summary>
    /// Deserializes a JSON string to a Part object.
    /// </summary>
    /// <param name="jsonString">The JSON string to deserialize.</param>
    /// <param name="options">Optional JsonSerializerOptions.</param>
    /// <returns>The deserialized Part object, or null if deserialization fails.</returns>
    public static Part ? FromJson(string jsonString, JsonSerializerOptions? options = null) {
      try {
        return JsonSerializer.Deserialize<Part>(jsonString, options);
      } catch (JsonException e) {
        Console.Error.WriteLine($"Error deserializing JSON: {e.ToString()}");
        return null;
      }
    }
  }
}
